module.exports = ($) ->
  _ = $._

  fn = (content) ->
    $.i fn.list(content).join '\n'

  fn.list = (content) ->
    list = []

    for a in "#{content}\n# Generated by CoffeeBasic 0.0.1".replace(/\r/g, '\n').split '\n'
      if !_.trim(a).length then continue

      list.push fn.parse a

    list

  fn.deep = (string) ->
    list = fn.deep.$list
    deep = fn.deep.$deep
    last = fn.deep.$last

    d = do ->
      if string[0] != ' ' then return 0
      Math.ceil string.match(/\s+/)[0].length / 2

    if d > deep
      list[d] = do ->
        if ~last.search ' ->' then 'sub'
        else if ~last.search ' =>' then 'function'
        else if ~last.search 'for ' then 'for'
        else if ~last.search 'switch ' then 'switch'
        else if ~last.search ' when ' then 'case'
        else if ~last.search /(?:\sif|if\s)/ then 'if'
        else 'string'
      #record function name
      if ~last.search ' =>'
        fn.parse.$fnName = _.trim last.replace /\s=.*/, ''
    else if d < deep

      arr = []
      do check = (_d = deep) ->
        if _d <= d then return

        prefix = _.repeat ' ', (_d - 1) * 2

        switch list[_d]
          when 'if' then arr.push "#{prefix}end if"
          when 'switch' then arr.push "#{prefix}end select"
          when 'case' then arr.push "#{prefix}end case"
          when 'for' then arr.push "#{prefix}next"
          when 'sub' then arr.push "#{prefix}end sub"
          when 'function' then arr.push "#{prefix}end function"

        list[_d] = ''
        check _d - 1

      string = "#{arr.join '\n'}\n#{string}"

    fn.deep.$deep = d
    fn.deep.$last = string

  fn.deep.$list = []
  fn.deep.$deep = 0
  fn.deep.$last = ''

  fn.namespace = (string) ->
    switch string[0]
      when '$' then _.camelCase string.replace(/\$/, 'cb').replace /\./g, '_'
      when '_' then _.camelCase string.replace /_/, 'temp '
      else string

  fn.parse = (string) ->
    fn.deep string

    #"aaa#{bbb}ccc"
    .replace /".*#\{.*?}.*"/g, (text) ->
      text.replace /#{/g, '" & '
      .replace /}/g, ' & "'
      .replace /"" &/g, ''
      .replace /& ""/g, ''

    #true and false
    .replace /true/g, '-1'
    .replace /false/g, '0'

    #_ to temp
    .replace /_\w+/g, (text) -> fn.namespace text
    #$. to cb
    .replace /\$\.(?:\w|\.)+/g, (text) -> fn.namespace text

    #replace all ' to ""
    .replace /'/g, '"'
    #replace all == to =
    .replace /==/g, '='
    #replace all != to <>
    .replace /!=/g, '<>'

    #replace -1 to `~1
    .replace /-(\d)/g, '`~$1'

    #quote
    .replace /#.*/g, (text) ->
      text.replace /#/, '`%`'
      .replace /\s/g, '_'

    #call
    .replace /(\w+)\(\)/g, 'call $1()'
    .replace /\.call /g, '.'
    .replace /(\S) call/g, '$1'

#    #dim
#    .replace /(\w+) = \[(.*?)]/g, (text) ->
#      key = _.trim text.replace /\s=.*/, ''
#      res = ["dim #{key}()"]
#
#      vList = text.replace(/.*\[/, '').replace(/].*/, '').replace(/\s*/g, '').split ','
#      if vList.length and vList[0].length
#        for a, i in vList
#          res.push "#{key}(#{i}) = #{a}"
#
#      res.join ' : '
#
#    #array
#    .replace /(\w+)\[(\d+?)\]/g, '$1($2)'

    #special format
    .replace /(end|gosub|delay|leftClick|leftUp|leftDown|rightClick|rightUp|rightDown|keyDown|keyUp|moveTo|findPic)\((.*?)\)/g, '$1 $2'

    #vb string
    .replace /call (randomize)\(\)/g, '$1'

    #sub
    .replace /\= ->/g, '= () ->'
    .replace /(\w+?) = \((.*)\) ->/g, 'sub $1($2)'
    #function
    .replace /\= =>/g, '= () =>'
    .replace /(\w+?) = \((.*)\) =>/g, 'function $1($2)'
    .replace /(\w+) = (\w+) ([^+\-*\/:]+)/g, '$1 = $2($3)'


    #return
    .replace /return/g, 'exit sub'
    .replace /exit sub .+/g, (text) ->
      res = text.replace /exit sub /, "#{fn.namespace fn.parse.$fnName} = "
      "#{res} : exit function"

    #if
    .replace /else if/g, 'elseif'
    .replace /(\s*)end if\n\1(else|elseif)/g, '$1$2'
    .replace /(if|else) (.+?)(.*)/g, '$1 $2$3 then'

    #switch
    .replace /switch (\w+)/g, 'select case $1'
    .replace /when (\S+)/g, 'case $1'
    .replace /(\s+)end case\n\1else/g, '$1case else'
    .replace /\s+end case\n/g, ''

    #for
    .replace /for (\w+) in \[(\w+?)\.+?(\w+?)]/g, 'for $1 = $2 to $3'

    #remove useless ()
    .replace /\((\+|-|\*|\/)\)/g, ' $1'

    #-1 back
    .replace /`~(\d)/g, '-$1'

    #quote back
    .replace /`%`.*/g, (text) ->
      text.replace /`%`/g, "//"
      .replace /_/g, ' '

  #return
  fn