module.exports = ($) ->
  _ = $._

  fn = (content) ->
    $.i fn.list(content).join '\n'

  fn.list = (content) ->
    list = []

    for a in "#{content}\n# Generated by CoffeeBasic 0.0.1".replace(/\r/g, '\n').split '\n'
      if !_.trim(a).length then continue

      list.push fn.parse a

    list

  fn.deep = (string) ->
    list = fn.deep.$list
    deep = fn.deep.$deep
    last = fn.deep.$last

    d = do ->
      if string[0] != ' ' then return 0
      Math.ceil string.match(/\s+/)[0].length / 2

    if d > deep
      list[d] = do ->
        if ~last.search ' ->' then 'sub'
        else if ~last.search ' =>' then 'function'
        else if ~last.search 'for ' then 'for'
        else if ~last.search 'switch ' then 'switch'
        else if ~last.search ' when ' then 'case'
        else if ~last.search /(?:\sif|if\s)/ then 'if'
        else 'string'
    else if d < deep

      arr = []
      do check = (_d = deep) ->
        if _d <= d then return

        prefix = _.repeat ' ', (_d - 1) * 2

        switch list[_d]
          when 'if' then arr.push "#{prefix}end if"
          when 'switch' then arr.push "#{prefix}end select"
          when 'case' then arr.push "#{prefix}end case"
          when 'for' then arr.push "#{prefix}next"
          when 'sub' then arr.push "#{prefix}end sub"
          when 'function' then arr.push "#{prefix}end function"

        list[_d] = ''
        check _d - 1

      string = "#{arr.join '\n'}\n#{string}"

    fn.deep.$deep = d
    fn.deep.$last = string

  fn.deep.$list = []
  fn.deep.$deep = 0
  fn.deep.$last = ''

  fn.parse = (string) ->
    fn.deep string
    #"aaa#{bbb}ccc"
    .replace /"(.*)#\{(.*)}(.*)"/g, '"$1" & $2 & "$3"'

    #replace all ' to ""
    .replace /'/g, '"'
    #replace all == to =
    .replace /==/g, '='
    #replace all != to <>
    .replace /!=/g, '<>'

    #quote
    .replace /#.*/g, (text) ->
      text.replace /#/, '_%_'
      .replace /\s/g, '_'

    #call
    .replace /(\w+)\(\)/g, 'call $1()'
    .replace /\.call /g, '.'

    #special format
    .replace /(end|gosub|delay|leftClick|rightClick|keyDown|keyUp|moveTo|findPic)\((.*?)\)/g, '$1 $2'

    #sub
    .replace /\= ->/g, '= () ->'
    .replace /(\w+?) = \((.*)\) ->/g, 'sub $1($2)'
    #function
    .replace /\= =>/g, '= () =>'
    .replace /(\w+?) = \((.*)\) =>/g, 'function $1($2)'

    #return
    .replace /return/g, 'exit sub'

    #if
    .replace /else if/g, 'elseif'
    .replace /(\s*)end if\n\1(else|elseif)/g, '$1$2'
    .replace /(if|else) (.+?)(.*)/g, '$1 $2$3 then'

    #switch
    .replace /switch (\w+)/g, 'select case $1'
    .replace /when (\S+)/g, 'case $1'
    .replace /(\s+)end case\n\1else/g, '$1case else'
    .replace /\s+end case\n/g, ''

    #for
    .replace /for (\w+) in \[(\w+?)\.+?(\w+?)]/g, 'for $1 = $2 to $3'

    #quote back
    .replace /_%_.*/g, (text) ->
      text.replace /_%_/g, "//"
      .replace /_/g, ' '

  #return
  fn